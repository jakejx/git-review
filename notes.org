* Architecture

** Variables

Public variables.

#+begin_src elisp
  (defvar git-review-change-id nil "The unique id of a change.")
  (defvar git-review-patchset nil "The patchset of the current change.")
  (defvar git-review-project nil "The name of the current project.")
  (defvar git-review-add-remote-conversations nil "Function that returns remote conversations.")
#+end_src

Private variables.

#+begin_src elisp
  (defvar git-review--changes nil "All changes.")
  (defvar git-review--change nil "The current change.")
  (defvar git-review--patchset nil "The current patchset.")
  (defvar git-review--rebased-files nil "List of files that are rebased.")
  (defvar git-review--unchanged-files nil "List of files that are unchanged.")
  (defvar git-review--conversations nil "List of conversations.")
#+end_src

** Data structures

*** Changes

=git-review--changes= is a list of property lists.

#+begin_src elisp
  '((:id "change-id1"
         :conversations (list)
         :patchsets (list)
         :project "project-name"
         :review-metadata (list)
         :current-patchset 2)
    (:id "change-id2"
         ...))
#+end_src

*** Patchset

A patchset is a property list.

#+begin_src elisp
  '(:commit-hash "sha1"
                 :parent-hash "sha1"
                 :current-file "file1.cpp"
                 :previous-file "file2.cpp"
                 :base-patchset 1
                 :files (list))
#+end_src

*** Conversations

A conversation is a property list.

#+begin_src elisp
  '(:id "identifier"
        :comments (list)
        :resolved t
        :location '((start-line . 5)
                    (end-line . 6)
                    (start-column . 10)
                    (end-column . 20))
        :commentable t)
#+end_src

*** Comments

A comment is a property list.

#+begin_src elisp
  '(:id "identifier"
        :user "John Doe"
        :message "Hello"
        :remote t
        :side a
        :published t)
#+end_src

*** File

A file is a property list.

#+begin_src elisp
  '(:filename "foo.cpp"
              :original-filename "bar.cpp"
              :type "MODIFIED"
              :metadata '((autogenerated . t)))
#+end_src

*** Review Metadata

A metadata is a property list.

#+begin_src elisp
  '(:id "ps1"
        :reviewed-files ("foo.cpp")
        :rebased-files ("bar.cpp")
        :unchanged-files ("baz.cpp"))
#+end_src

** Implementation details

Updating an existing change with =pushnew= doesn't work.

#+begin_src elisp
  (let ((changes '((:id 1 :name "niklas")
                   (:id 2 :name "tira"))))
    (cl-pushnew '(:id 1 :name "katarina")
                changes
                :test (lambda (a b) (equal (plist-get a :id) (plist-get b :id))))
    changes)
#+end_src

#+RESULTS:
| :id | 1 | :name | niklas |
| :id | 2 | :name | tira   |

Updating an existing change with =push= and =seq-remove=.

#+begin_src elisp
  (let ((changes '((:id 1 :name "niklas")
                   (:id 2 :name "tira")))
        (change '(:id 1 :name "katarina")))
    ;; Delete existing change
    (setq changes
          (seq-remove (lambda (it)
                        (equal (plist-get it :id)
                               (plist-get change :id)))
                      changes))
    ;; Add updated change
    (push change changes)
    changes)

#+end_src

#+RESULTS:
| :id | 1 | :name | katarina |
| :id | 2 | :name | tira     |

* Design decisions

** Conversations can not overlap

To simplify the code conversations are assumed to never overlap with another. This simplifies the implementation when it comes to decision about which conversation to highlight or open when a user's point is on a conversation region.

** Only one review at a time

The user can not review more than one change at a time. Since the package features a highly capable resume it is favorable if the user quits the review before switching. Because the package lacks a buffer that is kept throughout the review it is difficult to keep track of the review without using a global state and hence limiting the possibility of having multiple active reviews.

* Experiments
** Overlays

#+begin_src elisp
  (defun foo-overlay ()
    (interactive)
    (let* ((ov (make-overlay (point-min) (+ (point-min) 30)))
           (map (make-sparse-keymap)))
      (define-key map [follow-link] (kbd "<mouse-1>"))
      (define-key map (kbd "<mouse-1>")
                  (lambda (&rest args)
                    (interactive)
                    (message "Clicked on overlay")))
      (overlay-put ov 'before-string (propertize "Hello there\n" 'cursor t))
      (overlay-put ov 'face 'error)
      (overlay-put ov 'keymap map)))
#+end_src

#+RESULTS:
: foo-overlay
* Improvements

- [ ] Refactor code to avoid code duplication
- [ ] Add convenient functions to reduce code
- [ ] Add proper faces for users to control the design


